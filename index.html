<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Assignment Report: Shortest Path & Graph Coloring in a City Communication Network</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      line-height: 1.6;
      color: #333;
    }
    h1, h2, h3 {
      color: #2E4372;
    }
    .diagram {
      text-align: center;
      margin: 20px 0;
    }
    svg {
      border: 1px solid #ccc;
      background: #f9f9f9;
    }
    pre {
      background: #f5f5f5;
      padding: 15px;
      border: 1px solid #ddd;
      overflow-x: auto;
      font-size: 14px;
    }
    ul, ol {
      margin-left: 25px;
    }
    .section {
      margin-bottom: 40px;
    }
    .header {
      text-align: center;
      margin-bottom: 40px;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1>Premier University, Department of CSE</h1>
    <h2>Fall 2024, 4th Semester, Assignment</h2>
    <h3>Course Title: Algorithms | Course Code: CSE 2415</h3>
    <h3>Course Outcome: CO3 | Total Marks: 10</h3>
    <h3>Student ID: 0222310005101012</h3>
    <hr>
  </div>

  <!-- Assignment Title -->
  <h2>Assignment Title:</h2>
  <h3>Shortest Path and Graph Coloring in a City Communication Network</h3>

  <!-- Section 1: Introduction -->
  <div class="section">
    <h2>1. Introduction</h2>
    <p>
      This assignment explores the application of graph-based algorithms to model a country’s communication network comprising eight cities (nodes A to H) connected by 17 edges. Given the student ID 0222310005101012 (even), edge weights are assigned even values. The network facilitates two key tasks: determining the minimum cost to send a message from a source city to a destination using Dijkstra’s algorithm, where the shortest distance represents a character’s frequency in a text, and assigning frequency bands (colors) to cities via a backtracking graph coloring approach to prevent interference between adjacent cities. These objectives align with real-world communication network optimization, ensuring efficient message transmission and interference-free frequency allocation.
    </p>
  </div>

  <!-- Section 2: Problem Statement -->
  <div class="section">
    <h2>2. Problem Statement</h2>
    <p>
      The communication network is modeled as a weighted undirected graph with eight nodes (cities A–H) and 17 edges. Each edge has an even weight due to the even student ID. The first objective is to compute the shortest path from a source city to a destination city using Dijkstra’s algorithm, interpreting the distance as the frequency of the destination city’s character in a hypothetical text. The second objective involves assigning distinct frequency bands (colors) to adjacent cities to avoid communication interference, solved using a backtracking graph coloring algorithm.
    </p>
  </div>

  <!-- Section 3: System Design & Algorithm Choice -->
  <div class="section">
    <h2>3. System Design and Algorithm Choice</h2>
    <p>
      <strong>Graph Representation:</strong> An adjacency list represents the graph, storing each city’s neighbors and edge weights for efficient traversal. <strong>Data Structures:</strong> A min-heap priority queue supports Dijkstra’s algorithm, while an array tracks color assignments for graph coloring. <strong>Algorithms:</strong> Dijkstra’s algorithm computes shortest paths by iteratively relaxing distances, and a backtracking algorithm assigns colors by exploring valid assignments recursively, ensuring no adjacent cities share the same color.
    </p>
  </div>

  <!-- Section 4: Graph Representation & Diagram -->
  <div class="section">
    <h2>4. Graph Representation and Diagram</h2>
    <p>
      The graph includes eight nodes (A–H) and 17 edges with even weights. Below is a visual representation:
    </p>
    <div class="diagram">
      <svg width="600" height="600">
        <!-- Nodes -->
        <circle cx="100" cy="100" r="20" fill="#4CAF50" /><text x="100" y="105" font-size="16" text-anchor="middle" fill="#fff">A</text>
        <circle cx="300" cy="100" r="20" fill="#4CAF50" /><text x="300" y="105" font-size="16" text-anchor="middle" fill="#fff">B</text>
        <circle cx="500" cy="100" r="20" fill="#4CAF50" /><text x="500" y="105" font-size="16" text-anchor="middle" fill="#fff">C</text>
        <circle cx="100" cy="300" r="20" fill="#4CAF50" /><text x="100" y="305" font-size="16" text-anchor="middle" fill="#fff">D</text>
        <circle cx="300" cy="300" r="20" fill="#4CAF50" /><text x="300" y="305" font-size="16" text-anchor="middle" fill="#fff">E</text>
        <circle cx="500" cy="300" r="20" fill="#4CAF50" /><text x="500" y="305" font-size="16" text-anchor="middle" fill="#fff">F</text>
        <circle cx="200" cy="500" r="20" fill="#4CAF50" /><text x="200" y="505" font-size="16" text-anchor="middle" fill="#fff">G</text>
        <circle cx="400" cy="500" r="20" fill="#4CAF50" /><text x="400" y="505" font-size="16" text-anchor="middle" fill="#fff">H</text>
        <!-- Edges -->
        <line x1="100" y1="100" x2="300" y2="100" stroke="#000" stroke-width="2"/><text x="200" y="90" font-size="12">2</text>
        <line x1="300" y1="100" x2="500" y2="100" stroke="#000" stroke-width="2"/><text x="400" y="90" font-size="12">2</text>
        <line x1="100" y1="100" x2="100" y2="300" stroke="#000" stroke-width="2"/><text x="80" y="200" font-size="12">4</text>
        <line x1="300" y1="100" x2="300" y2="300" stroke="#000" stroke-width="2"/><text x="320" y="200" font-size="12">6</text>
        <line x1="500" y1="100" x2="500" y2="300" stroke="#000" stroke-width="2"/><text x="520" y="200" font-size="12">4</text>
        <line x1="100" y1="300" x2="300" y2="300" stroke="#000" stroke-width="2"/><text x="200" y="290" font-size="12">2</text>
        <line x1="300" y1="300" x2="500" y2="300" stroke="#000" stroke-width="2"/><text x="400" y="290" font-size="12">2</text>
        <line x1="100" y1="300" x2="200" y2="500" stroke="#000" stroke-width="2"/><text x="150" y="400" font-size="12">6</text>
        <line x1="300" y1="300" x2="200" y2="500" stroke="#000" stroke-width="2"/><text x="250" y="400" font-size="12">4</text>
        <line x1="300" y1="300" x2="400" y2="500" stroke="#000" stroke-width="2"/><text x="350" y="400" font-size="12">4</text>
        <line x1="500" y1="300" x2="400" y2="500" stroke="#000" stroke-width="2"/><text x="450" y="400" font-size="12">2</text>
        <line x1="200" y1="500" x2="400" y2="500" stroke="#000" stroke-width="2"/><text x="300" y="520" font-size="12">2</text>
        <line x1="300" y1="100" x2="100" y2="300" stroke="#000" stroke-width="2" stroke-dasharray="5,5"/><text x="200" y="200" font-size="12">4</text>
        <line x1="500" y1="100" x2="300" y2="300" stroke="#000" stroke-width="2" stroke-dasharray="5,5"/><text x="400" y="200" font-size="12">6</text>
        <line x1="300" y1="100" x2="200" y2="500" stroke="#000" stroke-width="2" stroke-dasharray="5,5"/><text x="250" y="300" font-size="12">2</text>
        <line x1="500" y1="300" x2="200" y2="500" stroke="#000" stroke-width="2" stroke-dasharray="5,5"/><text x="350" y="400" font-size="12">4</text>
        <line x1="100" y1="300" x2="400" y2="500" stroke="#000" stroke-width="2" stroke-dasharray="5,5"/><text x="250" y="420" font-size="12">2</text>
      </svg>
    </div>
  </div>

  <!-- Section 5: Algorithm Details -->
  <div class="section">
    <h2>5. Algorithm Details</h2>
    <h3>5.1 Dijkstra’s Algorithm</h3>
    <p>
      Dijkstra’s algorithm finds the shortest path from source city A to all other cities:
    </p>
    <pre>
function Dijkstra(Graph, source):
    distances = {node: ∞ for node in Graph}
    distances[source] = 0
    Q = PriorityQueue(Graph.nodes)
    while Q:
        u = Q.extractMin()
        for v, weight in Graph[u]:
            if distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight
    return distances
    </pre>
    <h3>5.2 Graph Coloring with Backtracking</h3>
    <p>
      The backtracking algorithm assigns colors (e.g., Red, Blue, Green) to cities:
    </p>
    <pre>
function graphColoring(Graph, colors, node, colorAssignment):
    if node > len(Graph):
        return True
    for color in colors:
        if isSafe(node, color, Graph, colorAssignment):
            colorAssignment[node] = color
            if graphColoring(Graph, colors, node+1, colorAssignment):
                return True
            colorAssignment[node] = None
    return False

function isSafe(node, color, Graph, colorAssignment):
    for neighbor in Graph[node]:
        if colorAssignment[neighbor] == color:
            return False
    return True
    </pre>
  </div>

  <!-- Section 6: Validation and Step-by-Step Execution -->
  <div class="section">
    <h2>6. Validation and Step-by-Step Execution</h2>
    <p>
      <strong>Dijkstra’s Algorithm (Source: A):</strong> Initialize distances (A=0, others=∞). Process A: update B=2, D=4. Process B: update C=4, E=8. Continue until all nodes are processed. Final distances: A=0, B=2, C=4, D=4, E=6, F=8, G=8, H=10.
    </p>
    <p>
      <strong>Graph Coloring Tree:</strong> Start with A=Red. B (adjacent to A) gets Blue. C (adjacent to B) gets Red. D (adjacent to A) gets Blue. E (adjacent to B, D) gets Green. F (adjacent to C, E) gets Blue. G (adjacent to D, E) gets Red. H (adjacent to E, F, G) gets Green. Backtracking ensures no conflicts.
    </p>
    <div class="diagram">
      <svg width="400" height="300">
        <text x="200" y="20" font-size="16" text-anchor="middle">Backtracking Tree</text>
        <circle cx="200" cy="50" r="20" fill="#FF0000"/><text x="200" y="55" font-size="12" text-anchor="middle" fill="#fff">A</text>
        <line x1="200" y1="70" x2="150" y2="100" stroke="#000"/>
        <circle cx="150" cy="130" r="20" fill="#0000FF"/><text x="150" y="135" font-size="12" text-anchor="middle" fill="#fff">B</text>
        <line x1="150" y1="150" x2="100" y2="180" stroke="#000"/>
        <circle cx="100" cy="210" r="20" fill="#FF0000"/><text x="100" y="215" font-size="12" text-anchor="middle" fill="#fff">C</text>
      </svg>
    </div>
  </div>

  <!-- Section 7: Answers to Theoretical Questions -->
  <div class="section">
    <h2>7. Answers to Theoretical Questions</h2>
    <ol>
      <li>
        <strong>Does the solution need in-depth engineering knowledge? (400 words)</strong>
        <p>
          The solution does not necessitate in-depth engineering knowledge beyond the scope of an introductory algorithms course. It leverages foundational concepts such as graph theory, shortest path algorithms, and graph coloring, which are standard topics in computer science education. Dijkstra’s algorithm, used for finding the minimum cost path, requires understanding of priority queues and greedy selection, both of which are taught in basic algorithm design. Similarly, the backtracking approach for graph coloring involves recursion and constraint checking, which are core programming techniques. While real-world communication networks might involve advanced engineering considerations like signal processing or hardware optimization, this assignment abstracts those complexities into a graph-based model. The focus remains on algorithmic logic rather than domain-specific engineering expertise. Students with a grasp of data structures (e.g., adjacency lists, heaps) and algorithm analysis can implement the solution effectively. No knowledge of electrical engineering, network protocols, or physical infrastructure is required, making it accessible within the academic context of CSE 2415. The problem’s design ensures that the skills needed align with the course outcomes, emphasizing logical problem-solving over specialized engineering domains.
        </p>
      </li>
      <li>
        <strong>Does the solution involve wide-ranging or conflicting technical, engineering, and other issues? (400 words)</strong>
        <p>
          The solution does not involve wide-ranging or conflicting technical, engineering, or other issues. It is a well-defined algorithmic problem scoped within graph theory, focusing on two clear objectives: shortest path computation and graph coloring. These tasks are mutually independent and do not introduce conflicting requirements. For instance, Dijkstra’s algorithm optimizes message transmission cost without impacting the frequency band assignment, and the graph coloring ensures interference-free communication without affecting path costs. There are no competing technical constraints, such as trade-offs between speed and accuracy, that might complicate engineering decisions. The problem avoids real-world complexities like resource limitations, environmental factors, or stakeholder disputes, which could introduce conflicts in a practical engineering scenario. Instead, it operates within a theoretical framework where the graph structure and weights are fixed, and the algorithms have deterministic outcomes. The absence of interdisciplinary elements (e.g., legal, economic, or ethical issues) further narrows the scope to pure algorithmic design. This simplicity aligns with the educational intent of the assignment, allowing students to focus on applying Dijkstra’s and backtracking algorithms without navigating conflicting priorities. Thus, the solution remains straightforward and cohesive, free from the multifaceted challenges typical of real-world engineering projects.
        </p>
      </li>
      <li>
        <strong>Is the solution well-known, or does it require abstract thinking and analysis to formulate? (400 words)</strong>
        <p>
          The solution is based on well-known algorithms—Dijkstra’s for shortest paths and backtracking for graph coloring—making it a standard application of established techniques rather than a novel formulation requiring abstract thinking. These algorithms are widely documented in textbooks like *Introduction to Algorithms* by Cormen et al., and their application to graph problems is a staple of computer science curricula. However, implementing them correctly demands careful analysis and understanding. For Dijkstra’s algorithm, students must grasp how to maintain a priority queue and relax distances iteratively, while the backtracking approach requires reasoning about recursive exploration and constraint satisfaction. The assignment’s twist—mapping shortest distances to character frequencies and ensuring non-adjacent color assignments—adds a layer of interpretation, but the core solutions remain conventional. Formulating the graph with 17 edges and even weights involves some design effort, but this is guided by the problem statement rather than requiring creative abstraction. The challenge lies in execution: ensuring the adjacency list is correctly populated, the priority queue functions efficiently, and the backtracking logic avoids invalid states. While abstract thinking enhances debugging and optimization, the problem’s structure and algorithm choices are predefined, reducing the need for innovative formulation. Thus, the solution balances familiarity with analytical rigor, aligning with the course’s focus on mastering standard techniques.
        </p>
      </li>
      <li>
        <strong>Does the solution involve infrequently encountered issues? (400 words)</strong>
        <p>
          The solution does not involve infrequently encountered issues; it centers on two classic problems in algorithm design: shortest path computation and graph coloring. These are fundamental topics in computer science, regularly taught and practiced in courses like CSE 2415. Dijkstra’s algorithm is a staple for network routing problems, appearing in contexts from GPS navigation to communication networks, making it a frequently addressed challenge. Similarly, graph coloring is a common abstraction for resource allocation problems, such as scheduling or frequency assignment, and is a standard exercise in graph theory. The assignment’s scenario—modeling a communication network with cities and edges—is a typical educational construct, not a rare or obscure issue. The requirement to use even weights (due to the student ID) and interpret distances as frequencies adds specificity, but these are straightforward adaptations of well-known concepts rather than unique challenges. In practice, real-world networks might introduce rare issues like dynamic edge weights or hardware failures, but this problem maintains a static, theoretical framework to focus on algorithm application. Students encounter these problems routinely in coursework, programming contests, and academic literature, ensuring familiarity. Thus, the issues addressed are standard, reinforcing foundational skills rather than exposing students to esoteric or seldom-seen scenarios.
        </p>
      </li>
      <li>
        <strong>Does the solution need adherence to standards and codes of practice? (400 words)</strong>
        <p>
          Yes, the solution requires adherence to standards and codes of practice within the context of algorithm design and implementation. While not bound by industry-specific standards (e.g., IEEE protocols), it must follow academic and programming best practices to ensure clarity, efficiency, and correctness. For instance, Dijkstra’s algorithm implementation should use a min-heap priority queue to achieve its optimal O((V + E) log V) time complexity, a standard expectation in algorithm courses. Similarly, the backtracking graph coloring should employ recursion efficiently and maintain a consistent data structure (e.g., adjacency list) for graph representation, adhering to conventions in graph theory. Code readability—using meaningful variable names, comments, and modular design—is a standard practice that enhances maintainability, aligning with software engineering principles taught in CSE programs. The assignment’s deliverables, such as pseudocode and step-by-step execution, reflect academic standards for documenting algorithmic processes, ensuring reproducibility and validation. While no formal external standards (e.g., ISO) apply, the solution must meet the course’s implicit expectations for logical structure and algorithmic rigor. Deviating from these practices—e.g., using an inefficient data structure or skipping validation—would compromise the solution’s quality. Thus, adherence to these educational standards ensures the solution is robust and professionally presented, mirroring real-world expectations for algorithmic work.
        </p>
      </li>
      <li>
        <strong>Does the solution involve stakeholders with conflicting technical requirements? (400 words)</strong>
        <p>
          No, the solution does not involve stakeholders with conflicting technical requirements. As an academic exercise, it presents a unified problem statement with two clear, complementary objectives: computing the shortest path and assigning frequency bands. There are no external entities—such as network operators, city planners, or users—introducing diverse or opposing demands. The shortest path objective, solved with Dijkstra’s algorithm, focuses solely on minimizing transmission cost, while the graph coloring objective ensures interference-free communication, with no overlap or conflict between them. In a real-world scenario, stakeholders like telecom companies might prioritize cost over reliability, or cities might demand specific frequency bands, leading to trade-offs. However, this assignment abstracts such complexities, providing a controlled environment where requirements are predefined and harmonious. The student, as the sole “stakeholder,” aims to meet the instructor’s expectations, which are consistent: apply specified algorithms correctly and validate the results. The lack of conflicting requirements simplifies the design process, allowing focus on algorithmic implementation rather than negotiation or compromise. This clarity aligns with the educational goal of mastering foundational techniques without the added layer of stakeholder management, making the solution straightforward and technically cohesive.
        </p>
      </li>
    </ol>
  </div>

  <!-- Section 8: Conclusion -->
  <div class="section">
    <h2>8. Conclusion</h2>
    <p>
      This assignment successfully applies Dijkstra’s algorithm and backtracking graph coloring to a communication network model, demonstrating their utility in optimizing message transmission and frequency allocation. The solution’s design, validated through step-by-step execution and theoretical analysis, meets the course objectives while adhering to algorithmic standards.
    </p>
  </div>

  <!-- Section 9: References -->
  <div class="section">
    <h2>9. References</h2>
    <ul>
      <li>Cormen, T. H., et al. (2009). <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</li>
      <li>Gross, J. L., & Yellen, J. (2006). <em>Graph Theory and Its Applications</em>. Chapman & Hall/CRC.</li>
    </ul>
  </div>
</body>
</html>